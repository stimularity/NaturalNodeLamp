{
  "name": "spi",
  "version": "0.1.2",
  "description": "JS Interface for the SPI bus",
  "author": {
    "name": "Russell Hay",
    "email": "me@russellhay.com",
    "url": "http://russellhay.com"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/RussTheAerialist/node-spi.git"
  },
  "main": "./spi",
  "dependencies": {
    "bindings": "*"
  },
  "engines": {
    "node": "0.6"
  },
  "scripts": {
    "install": "node-gyp rebuild"
  },
  "gypfile": true,
  "readme": "node-spi\n========\n\nA NodeJS interface to the SPI bus typically found on embedded linux machines \nsuch as the Raspberry Pi.\n\nThere is a native interface and a wrapped JS interface with a slightly\nbetter API.\n\n*Note: The first version will be blocking. I know this is antithetical to\nthe node.js philosophy, but I think its important to get the code working in a \nblocking manner first, and then introduce the async calls using eio.*\n\n*Note2: I'm back from the dead, and will be resuming working on this project now, sorry for the\nlong silence and lack of support*\n\nIf you have a project that uses node-spi, please consider adding a link to your project on the wiki:\n\nhttps://github.com/RussTheAerialist/node-spi/wiki/Projects-that-use-node-spi\n\n\nBasic Usage\n===========\n\n```javascript\nvar SPI = require('spi');\n\nvar spi = new SPI.Spi('/dev/spidev0.0', {\n    'mode': SPI.MODE['MODE_0'],  // always set mode as the first option\n    'chipSelect': SPI.CS['none'] // 'none', 'high' - defaults to low\n  }, function(s){s.open();});\n\nvar txbuf = new Buffer([ 0x23, 0x48, 0xAF, 0x19, 0x19, 0x19 ]);\nvar rxbuf = new Buffer([ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 ]);\n\nspi.transfer(txbuf, rxbuf, function(device, buf) {\n    // rxbuf and buf should be the same here\n    var s = \"\";\n    for (var i=0; i < buf.length; i++)\n        s = s + buf[i] + \" \";\n        console.log(s + \"- \" + new Date().getTime());\n  });\n```\n\nHow you should **really** use the library\n=========================================\n\nThe above basic usage example is not how you should use the library, though.\nIdeally, for each SPI device that is being controlled should have it's own\nobject that implements the protocol necessary to talk to your device so that\nthe device protocol is defined in one place.\n\nAn example project is [node-adafruit-pixel](https://github.com/RussTheAerialist/node-adafruit-pixel)\nwhich is a node module to control the [AdaFruit RGB Pixels](http://www.adafruit.com/products/738).\nThe interface is defined in terms of color and pixels, and not in messages \nbeing sent via the SPI bus, but it uses node-spi to do it's work.\n\nNative Api Reference\n====================\n\nThis section documents the native api which is defined in module _spi.node.\nThis is the interface that the normal Spi interface uses, but having a good\nunderstanding of this part is important, as some people may want to use the\nnative interface directly.\n\nCreating, Opening, and Closing the device\n-----------------------------------------\n\n**\\_spi.Spi constructor** - The constructor only requires the path to the spi \ndev file in /dev. Options and a callback are not required but can be specified.\n\nExample:\n```javascript\nvar spi = new SPI.Spi('/dev/spidev0.1');\n```\n\nOptions can include:\n* mode\n* chipSelect\n* bitsPerWord\n* bitOrder\n* maxSpeed\n* halfDuplex\n* loopback\n\nExample:\n```javascript\nvar spi = new SPI.Spi('/dev/spidev0.0', {'mode': SPI.MODE['MODE_0']});\n```\n\nThe callback returns a handle to the newly created SPI object. It might be \nhandy to .open() it if you set all of your options in one shot.\n\nExample:\n```javascript\nvar spi = new SPI.Spi('/dev/spidev0.0', {}, function(s){s.open();});\n```\n\n**open()** - This function takes no arguments and will open the device using\nall of the options that were previously set.  Once the device is open, we do not\nallow you to change the settings on the device.\n\nExample:\n```javascript\nvar spi = new SPI.Spi('/dev/spidev0.0', {'mode': SPI.MODE['MODE_0']});\n\n// get/set aditional options\nspi.maxSpeed(20000); // in Hz\nconsole.log('max speed: ' + spi.maxSpeed());\n\nspi.open(); // once opened, you can't change the options\n```\n\n**close()** - This function should always be called before ending.  Right now\nthe destructor for the underlying C++ class does not call close(), but that\nmight change in the future.  You should always call close() when you are done\nwith the device.\n\nConfiguring the Device\n----------------------\n\nThe following functions all act as getter/setters.  If you do not pass an\nargument, it will return the value of the setting.  If you pass in a value,\nit will change the value and then return the Spi class to allow function\nchaining.\n\nTo understand these settings read the\n[Linux SPI Summary](http://www.mjmwired.net/kernel/Documentation/spi/spi-summary)\n\n**mode()** - This sets the clock phase and polarity of the clock signal.  This\nshould always be the first thing you call after open() if you plan to call it.\nBy default it is set to SPI_MODE_0.  The spi namespace provides constants for\nthe four SPI_MODE_X values (X being 0-3).\n\n**chipSelect()** - This allows you to specify if the chip select signal should\nbe used, and if it should go high to select the chip or low.  It defaults to\nsignal low.  Pass in SPI_NO_CS to turn off Chip Select, and SPI_CS_HIGH to\nturn on sending high to select.\n\n**bitsPerWord()** - This allows you to specify the bits per word to send.\nThis defaults to 8-bits.  Check your device's datasheet for this value.\n\n**bitOrder()** - This allows you to specify the order of the bits.  We default\nto MSB, but send True as the argument if you want LSB.  This might not be the\nbest API.\n\n**maxSpeed()** - This allows you to set the max transfer speed.  Again, check\nyour device's datasheet.  This is in Hz and defaults to 1Mhz.\n\n**halfDuplex()** - Set this to True if your device does not support full duplex.\nThis isn't fully supported yet, as I need to add a Read/Write function calls that\nis exposed to javascript. *This would be a great workitem for anyone who wants\nto contribute*\n\n**loopback()** - This sets the Loopback bit on the SPI controller.  I don't\nfully understand what this is used for, but give you the ability to toggle it\nif you'd like.\n\nGetting and Sending Data\n------------------------\n**transfer(txbuf, rxbuf, callback)** - This takes two buffers, a write and a \nread buffer, and optionally a callback. SPI only reads when a byte is written \nso communicaton is usually full duplex.\n\nExmple:\n```javascript\nvar txbuf = new Buffer([ 0x23, 0x48, 0xAF, 0x19, 0x19, 0x19 ]);\nvar rxbuf = new Buffer([ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 ]);\n\nspi.transfer(txbuf, rxbuf, function(device, buf) {\n    var s = \"\";\n    for (var i=0; i < buf.length; i++)\n        s = s + buf[i] + \" \";\n        console.log(s);\n  });\n```\n\nAs a convenience feature, read and write functions pad zeros in the opposite \ndirection to make simple read and writes work.\n\n**read(buffer, callback)** - Reads as much data as the given buffer is big. \nThe results of the read are available in the callback.\n\nExample:\n```javascript\nvar buf1 = new Buffer(8);\nspi.read(buf1, function(device, buf2) {\n    var s = \"\";\n    for (var i=0; i < buf.length; i++)\n      s = s + buf[i] + \" \";\n    console.log(s);\n  });\n```\n\n**write(buffer, callback)** - Writes out the given buffer.\n\nExample:\n```javascript\nvar buf = new Buffer([0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0]);\nspi.write(buf, function(device, buf2) {\n    var s = \"\";\n    for (var i=0; i < buf.length; i++)\n      s = s + buf[i] + \" \";\n    console.log(s);\n  });\n```\n\nRemember that these native apis are currently blocking.  I will update, once I\nhave the hardware to test this properly, to be async instead of blocking.\n",
  "readmeFilename": "README.md",
  "_id": "spi@0.1.2",
  "dist": {
    "shasum": "9925b6ff2972a2725a8e9191ae0c2f574c11e2cc"
  },
  "_from": "spi@0.x.x",
  "_resolved": "https://registry.npmjs.org/spi/-/spi-0.1.2.tgz"
}
